# Быстрая сортировка
Быстрая сортировка, сортировка Хоара (англ. quicksort), часто называемая qsort (по имени в стандартной библиотеке языка Си) — широко известный алгоритм сортировки, разработанный английским информатиком Чарльзом Хоаром во время его работы в МГУ в 1960 году.

Один из самых быстрых известных универсальных алгоритмов сортировки массивов: в среднем **O(n log n)** обменов при упорядочении **n** элементов; из-за наличия ряда недостатков на практике обычно используется с некоторыми доработками.

# Алгоритм
Быстрая сортировка использует стратегию «разделяй и властвуй». Шаги алгоритма таковы:

1. Выбираем в массиве некоторый элемент, который будем называть опорным элементом. Для корректности алгоритма значение этого элемента должно быть между максимальным и минимальным значениями в массиве (включительно). С точки зрения повышения эффективности алгоритма выгоднее всего выбирать медиану; но без дополнительных сведений о сортируемых данных её обычно невозможно получить. Известные стратегии: выбирать постоянно один и тот же элемент, например, средний или последний по положению; выбирать элемент со случайно выбранным индексом. Часто хороший результат даёт выбор в качестве опорного элемента среднего арифметического между минимальным и максимальным элементами массива, особенно для целых чисел (в этом случае опорный элемент не обязан быть элементом сортируемого массива).
2. Операция разделения массива: реорганизуем массив таким образом, чтобы все элементы со значением меньшим или равным опорному элементу, оказались слева от него, а все элементы, превышающие по значению опорный — справа от него. Обычный алгоритм операции:
    1. Два индекса — l и r, приравниваются к минимальному и максимальному индексу разделяемого массива, соответственно.
    2. Вычисляется значение опорного элемента m по одной из стратегий.
    3. Индекс l последовательно увеличивается до тех пор, пока l-й элемент не окажется больше или равен опорному.
    4. Индекс r последовательно уменьшается до тех пор, пока r-й элемент не окажется меньше или равен опорному.
    5. Если r = l — найдена середина массива — операция разделения закончена, оба индекса указывают на опорный элемент.
    6. Если l < r — найденную пару элементов нужно обменять местами и продолжить операцию разделения с тех значений l и r, которые были достигнуты. Следует учесть, что если какая-либо граница (l или r) дошла до опорного элемента, то при обмене значение m изменяется на r-й или l-й элемент соответственно, изменяется именно индекс опорного элемента и алгоритм продолжает своё выполнение.
3. Рекурсивно упорядочиваем подмассивы, лежащие слева и справа от опорного элемента.
4. Базой рекурсии являются наборы: пустой или состоящий из одного элемента, которые возвращаются в исходном виде. Все такие отрезки уже упорядочены в процессе разделения.

Поскольку в каждой итерации (на каждом следующем уровне рекурсии) длина обрабатываемого отрезка массива уменьшается, по меньшей мере, на единицу, терминальная ветвь рекурсии будет достигнута обязательно, и обработка гарантированно завершится.

[![Быстрая сортировка алгоритм GIF](https://cdn.rawgit.com/vasilyukvasiliy/Sorting-Algorithms-Speed/4a7ae8558ab772f67ac631131bb5a78599662f73/Documentation/images/Sorting_quicksort_anim.gif)](https://github.com/vasilyukvasiliy/Sorting-Algorithms-Speed/blob/master/Documentation/QuickSort.md#Алгоритм)

# Быстрая сортировка (QSort) код C++
~~~
template<typename quickSortType, typename quickSortNumberType>
void quickSort(int *array, quickSortType firstElementNumber, quickSortNumberType lastElementNumber) {
    quickSortType averageElementNumber, temp;
    quickSortNumberType leftElementNumber = firstElementNumber, rightElementNumber = lastElementNumber;
    averageElementNumber = array[leftElementNumber + (rightElementNumber - leftElementNumber) / 2];
    do {
        while (array[leftElementNumber] < averageElementNumber) leftElementNumber++;
        while (array[rightElementNumber] > averageElementNumber) rightElementNumber--;
        if (leftElementNumber <= rightElementNumber) {
            temp = array[leftElementNumber];
            array[leftElementNumber] = array[rightElementNumber];
            array[rightElementNumber] = temp;
            leftElementNumber++;
            rightElementNumber--;
        }
    } while (leftElementNumber < rightElementNumber);
    if (firstElementNumber < rightElementNumber) quickSort(array, firstElementNumber, rightElementNumber);
    if (leftElementNumber < lastElementNumber) quickSort(array, leftElementNumber, lastElementNumber);
}
~~~